
#+TITLE: Emacs initialization

* Emacs Initialization
:Properties:
:tangle: init.el
:END:

This document describes how Emacs is initialized.
** Run local pre-initialization

Run machine dependant initialization file before running the common
setup. This script could be used to set up proxies.

#+BEGIN_SRC emacs-lisp
  (setq local-pre-init-file "~/.emacs.d/local-pre-init.el")
  (if (file-exists-p local-pre-init-file)
  (load local-pre-init-file)
  )
#+END_SRC

Following kind of sniplet can be used to set up proxy. It tries to
ping the host and if it succeseed in on second it setups environment
variables. El-get will run git and without those variables cloning
repositories will fail.

#+BEGIN_EXAMPLE emacs-list
(if (= 0 (call-process "ping" nil nil nil "-W" "1" "-c" "1" "1.2.3.4"))
  (setenv "http_proxy" "1.2.3.4:8080")
  (setenv "https_proxy" "1.2.3.4:8080")
)
#+END_EXAMPLE

** Minimalistic user interface

Emacs shows startup screen. It gets anoying after a while, so they
need to be turned off.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (setq inhibit-splash-screen t)
#+END_SRC

After getting used to the keyboard interface the menus and such just
takes valuable screen space. So mouse interface is turned off.
This is done early in the initialization to prevent momentary display.

#+BEGIN_SRC emacs-lisp
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

** Exec path

At least in MacOS there is problems of ~exec-path~ being insufficient.
The main hedeach this causes is that gpg is not found and encrypted
files can not be opened or saved.

Following code will extract exec-path from ~PATH~ variable.

#+BEGIN_SRC emacs-lisp
(let ((elements (split-string (getenv "PATH") ":")))
  (dolist (e elements)
    (add-to-list 'exec-path e)))
#+END_SRC

In some cases ~bin~ directory in home directory is missing in the ~exec-path~. Same thing goes to the
~/usr/local/bin~. These are often used in my machines.

#+BEGIN_SRC emacs-lisp
(add-to-list 'exec-path "~/bin")
(add-to-list 'exec-path "/usr/local/bin")
#+END_SRC

** Lisp files

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/lisp/")
#+END_SRC

** Using GPG-Agent in MacOS

MacOS environment is "funny" thing there is different for shell and
different for applications. The gpg-agent can be configured to be
launched during login ([[http://www.weinschenker.name/2013-10-08/use-gpgtools-for-ssh-logins-on-mac-os-x/][how-to]]), but emacs does not receive the related
environment variables. Following code fixes this issue.

#+BEGIN_SRC emacs-lisp
  ;; read gpg-agent environment

  (defun read-env-line (line)
    "read a env line and post to environment"
    (let ((key-value-pair (split-string line "=" t)))
      (setenv (car key-value-pair) (car (last key-value-pair))))
    )
  (defvar gpg-agent-info-file)
  (setq gpg-agent-info-file (concat (getenv "HOME") "/.gpg-agent-info"))

  (when (and
         (eq system-type 'darwin)
         (file-exists-p gpg-agent-info-file))
        (with-temp-buffer
          (progn
            (insert-file-contents gpg-agent-info-file)
            (mapc 'read-env-line (split-string (buffer-string) "\n" t)))
          )
    )
#+END_SRC
** No tabs

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** No transient mark by default

Following disables [[https://www.emacswiki.org/emacs/TransientMarkMode][transient mark mode]]. This means that text is not selected by default like in "normal" editors.
This allows more convient text editing while it requires some practice.

#+BEGIN_SRC emacs-lisp
(transient-mark-mode 0)
#+END_SRC

** Allow narrowing buffer

After over year of practice I am begin to think that can start to lear some [[https://www.emacswiki.org/emacs/Narrowing][narrowing]]. It is disabled by default and
needs to be enabled.

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** Backups

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq
  delete-old-versions t
  kept-new-versions 6
  kept-old-versions 2
  version-control t
  backup-by-copying t
)
#+END_SRC

** Browser


#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
     (setq browse-url-browser-function 'browse-url-default-macosx-browser))
#+END_SRC

** Calendar

See http://orgmode.org/worg/org-faq.html#Appointments/Diary

#+begin_src emacs-lisp

(setq diary-file "~/org/diary")

;; (calendar-set-date-style 'european)

(setq calendar-week-start-day 1
      calendar-view-diary-initially-flag t
      calendar-mark-diary-entries-flag t)

(add-hook 'diary-display-hook 'diary-fancy-display)

#+end_src
** Emacsclient server

#+BEGIN_SRC emacs-lisp
(setq server-socket-dir "~/.emacs.d/server")
(server-start)
#+END_SRC

** Elget

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/el-get/el-get")

(unless (require 'el-get nil 'noerror)
  (with-current-buffer
      (url-retrieve-synchronously
       "https://raw.githubusercontent.com/dimitri/el-get/master/el-get-install.el")
    (goto-char (point-max))
    (eval-print-last-sexp)))

(require 'el-get-elpa)
;; Build the El-Get copy of the package.el packages if we have not
;; built it before.  Will have to look into updating later ...
(unless (file-directory-p el-get-recipe-path-elpa)
  (el-get-elpa-build-local-recipes))

(add-to-list 'el-get-recipe-path "~/.emacs.d/el-get-user/recipes")
(el-get 'sync)
#+END_SRC


** No passwords in shell

#+BEGIN_SRC emacs-lisp
;; No passwords show in shell
(add-hook 'comint-output-filter-functions
          'comint-watch-for-password-prompt)
#+END_SRC
** New prefix key Control-q

~Control-q~ is bound to ~quoted-insert~ by default. That command is
not use so often and the key is perfectly located for prefix key.
So it is unset here to allow it to be re-used later.

#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-q"))
#+END_SRC

** Org-mode

Install org mode through [[Elget]].

#+BEGIN_SRC emacs-lisp
;;(el-get-bundle org)
#+END_SRC

Set up agenda functionality. Files are located under org-directory
under home.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org")
(setq org-agenda-files (concat org-directory "/agenda"))
(setq org-default-notes-file (concat org-directory "/refile.org.gpg"))
#+END_SRC


Set up archive file that is encrypted. By default entries would be archive
to files postfixed by ~_archive~. This file is not encrypted and that could
be a problem.

#+BEGIN_SRC emacs-lisp
(setq org-archive-location (concat org-directory "/archive.org.gpg::* From %s"))
#+END_SRC


Setup default keys (see [[http://orgmode.org/org.html#Activation][Org mode activation]]). There has not been any
reason to change them yet.
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (makefile . t)
   (sh . t)
   (js . t)
   (plantuml . t)
   (emacs-lisp . t)
   (ditaa . t)
   ))
#+END_SRC


Active babel languages.
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (makefile . t)
   (sh . t)
   (js . t)
   (plantuml . t)
   (emacs-lisp . t)
   (ditaa . t)
   ))
#+END_SRC

Following will add GTD type of state for the tasks and
provide logging.
#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer t)
(setq org-todo-keywords
'(
(sequence "IN(i!)" "SOMEDAY(s!)" "WAIT(w@/!)" "TODO(t!)" "NEXT(n!)" "|" "DONE(d!)" "CANCELLED(c@)")
(sequence "|" "PHONE" "MEETING")
))
#+END_SRC

Log looks something like this under the task header line.
#+BEGIN_EXAMPLE
:LOGBOOK:
- State "DONE"       from "SOMEDAY"    [2016-02-22 Mon 16:04]
- State "SOMEDAY"    from "IN"         [2016-02-22 Mon 16:03]
- State "IN"         from "WAIT"       [2016-02-22 Mon 16:03]
:END:
#+END_EXAMPLE

This adds simple line that tells when the task has been closed.
#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
#+END_SRC

Improve how the stuck projects are found.
#+BEGIN_SRC emacs-lisp
(setq org-tags-exclude-from-inheritance '("PROJECT" "TARGET"))
(setq org-stuck-projects
           '("+PROJECT/-MAYBE-DONE" ("TODO")))
#+END_SRC

Capture templates
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(
          ("t" "Task" entry (file+headline org-default-notes-file "Tasks")
           "* IN %?\n  CREATED: %U\n  %i\n"
           :empty-lines 1)

          ("n" "Note" entry (file+headline org-default-notes-file "Notes")
           "* %? :NOTE:\n  CREATED: %U\n"
           :empty-lines 1)

          ("m" "Meeting" entry (file+headline org-default-notes-file "Meetings")
           "* MEETING %u %? :MEETING:\n CREATED: %U\n"
           :clock-in t :clock-resume t  :empty-lines 1)

          ("c" "Phone call" entry (file+headline org-default-notes-file "Calls")
           "* PHONE  %U %? :PHONE:\n CREATED: %U"
           :clock-in t :clock-resume t  :empty-lines 1)

          ("j" "Journal" entry (file+datetree "~/org/diary.org.gpg")
           "* %U\n\n%?")

          ("p" "Org-protocol, Selection" entry (file+headline org-default-notes-file "Tasks")
           "* IN Finnish note from %c :NOTE:captured:\n CREATED: %U\n\n From %c:\n\n#+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n"
           :immediate-finish t)

          ("L" "Org-protocol, Link" entry (file+headline org-default-notes-file "Tasks")
           "* IN Review [[%:link][%:description]] :captured: \n CREATED: %U\n\n"
:immediate-finish t)

          ))
#+END_SRC

Following enables org-protocol handling. This means that url-like ~org-protocol://capture:/p/<url>/<title>/selection>~
are handled by the org mode capture.

#+begin_src emacs-lisp 
(require 'org-protocol)
#+end_src

Refilling
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets '(
                             (org-agenda-files . (:tag . "PROJECT"))
                             (org-agenda-files . (:tag . "TARGET"))
                             ))
#+END_SRC

** COMMENT Mobile org

#+BEGIN_SRC emacs-lisp
(setq org-mobile-directory "~/Dropbox/MobileOrg")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-mobile-use-encryption nil)
#+END_SRC

** MacOS command keys as meta

Accidentally pressin command key in MacOS is annoying so they are configured to be as meta-keys. 
#+BEGIN_SRC
(setq ns-command-modifier 'meta)
(setq ns-right-command-modifier 'meta)
#+END_SRC

** Misc


#+BEGIN_SRC emacs-lisp
;;; turn on syntax highlighting
(global-font-lock-mode 1)

;; Mustache mode
(require 'mustache-mode)

(defun iwb ()
  "indent whole buffer"
  (interactive)
  (delete-trailing-whitespace)
  (indent-region (point-min) (point-max) nil)
  (untabify (point-min) (point-max)))

(defun previous-line-insert-newline ()
  "Moves line up and creates empty line"
  (interactive)
  (previous-line)
  (end-of-line)
  (newline-and-indent)
  )

(defun next-line-insert-newline ()
  "Moves line up and creates empty line"
  (interactive)
  (end-of-line)
  (newline-and-indent)
  )

(setq line-move-visual nil)
(put 'scroll-left 'disabled nil)

;; (global-set-key (kbd "C-,") 'backward-paragraph)
;; (global-set-key (kbd "C-.") 'forward-paragraph)
;; (global-set-key  (kbd "C-`")    'shell-command)
;; (global-set-key  (kbd "M-`")    'shell-command-on-region)

;; These need some more tought sou they dont`t override org-mode keys
;; (global-set-key (kbd "C-c <return>") 'set-rectangular-region-anchor)
;; (global-set-key (kbd "C-c c") 'mc/edit-lines)
;; (global-set-key (kbd "C-c a") 'mc/mark-all-like-this)
;; (global-set-key (kbd "C-c .") 'mc/mark-next-like-this)
;; (global-set-key (kbd "C-c ,") 'mc/mark-previous-like-this)
;; (global-set-key (kbd "C-c m") 'mc/mark-more-like-this-extended)

(global-set-key (kbd "C-c f") 'iwb)

;; Moving from window to window using arrows
(global-set-key (kbd "C-c <left>")  'windmove-left)
(global-set-key (kbd "C-c <right>") 'windmove-right)
(global-set-key (kbd "C-c <up>")    'windmove-up)
(global-set-key (kbd "C-c <down>")  'windmove-down)

(global-set-key (kbd "M-n") 'next-line-insert-newline)
(global-set-key (kbd "M-p") 'previous-line-insert-newline)



(global-unset-key (kbd "C-<SPC>"))
(global-set-key (kbd "C-<SPC>") 'set-mark-command)



(global-set-key (kbd "s-<left>")  'windmove-left)
(global-set-key (kbd "s-<right>") 'windmove-right)
(global-set-key (kbd "s-<up>")    'windmove-up)
(global-set-key (kbd "s-<down>")  'windmove-down)

(put 'upcase-region 'disabled nil)
(put 'scroll-left 'disabled nil)

(global-set-key (kbd "C-q o")  'find-file-at-point)


#+END_SRC

** Shell stuff 
*** Convient way to create new shell

I often need shell. But default ~M-x shell~ will throw back to the already created shell. Many times this is not what I want.

#+begin_src emacs-lisp
(defun new-shell ()
  (interactive)

  (let (
        (currentbuf (get-buffer-window (current-buffer)))
        (newbuf     (generate-new-buffer-name "*shell*"))
       )
   (generate-new-buffer newbuf)
   (set-window-dedicated-p currentbuf nil)
   (set-window-buffer currentbuf newbuf)
   (shell newbuf)
  )
)

(global-set-key (kbd "C-q s")  'new-shell)
#+end_src
*** Jumping to the root directory of repository

Sometimes it is convenient to jump to the root directory of the repository.

#+begin_src emacs-lisp
(defun pw/shell-cd-to-vc-root ()
"Jumps to the root directory of version controled directory structure."
  (interactive)
  (let* ((proc (get-buffer-process (current-buffer)))
         (pmark (process-mark proc))
	 (started-at-pmark (= (point) (marker-position pmark)))         
         (root (vc-root-dir))
         (cmd (concat "cd " root)))
    (save-excursion
      (goto-char pmark)
      (unless comint-process-echoes     
         (insert cmd) (insert "\n"))
      (sit-for 0)			; force redisplay      
      (cd root)
      (comint-send-string proc cmd)
      (comint-send-string proc "\n")
      (set-marker pmark (point))
      )
    
    (if started-at-pmark (goto-char (marker-position pmark)))))

(defun pw/dired-cd-to-vc-root ()
(interactive)
(find-file (vc-root-dir)))

#+end_src

This function can be binded to key sequence when shell is activated.
#+begin_src emacs-lisp
  (add-hook 'comint-mode-hook (lambda ()
                              (define-key comint-mode-map (kbd "C-q c r") 'pw/shell-cd-to-vc-root)
                              ))

  (add-hook 'dired-mode-hook (lambda ()
                              (define-key dired-mode-map (kbd "C-q c r") 'pw/dired-cd-to-vc-root)
                              ))

#+end_src
** Ace Jump
#+BEGIN_SRC emacs-lisp
  (el-get-bundle ace-jump-mode)

  (add-hook 'comint-mode-hook
                 (lambda ()
                   (define-key comint-mode-map (kbd "C-.") 'ace-jump-mode)
                   (define-key comint-mode-map (kbd "<C-return>") 'comint-accumulate)
                  ))

                 
  ;; 
  ;; enable a more powerful jump back function from ace jump mode
  ;;
  (autoload
    'ace-jump-mode-pop-mark
    "ace-jump-mode"
    "Ace jump back:-)"
    t)
  (eval-after-load "ace-jump-mode"
    '(ace-jump-mode-enable-mark-sync))
  (define-key global-map (kbd "C-q q") 'ace-jump-mode-pop-mark)
  (define-key global-map (kbd "C-.") 'ace-jump-mode)
#+END_SRC
** setup-autocomplete.el
#+BEGIN_SRC emacs-lisp
#+END_SRC
** setup-csv.el
#+BEGIN_SRC emacs-lisp
;; CSV Mode
(el-get-bundle csv-mode)
(require 'csv-mode)
#+END_SRC
** setup-docker-mode.el
#+BEGIN_SRC emacs-lisp
(el-get-bundle dockerfile-mode)
;;; Dockerfile mode
(require 'dockerfile-mode)
(add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))
#+END_SRC
** setup-edit-server.el
#+BEGIN_SRC emacs-lisp
(el-get-bundle edit-server)
(edit-server-start)
#+END_SRC
** setup-erlang.el
#+BEGIN_SRC emacs-lisp
(defun erl-exists () "Tests wether go is installed or not" 
  (= (call-process "which" nil nil nil "erl") 0)
)


(defun erl-setup () "Install erlang environment with el-get"
       (el-get-bundle erlang-mode)
)

(if (erl-exists) (erl-setup))
#+END_SRC
** setup-expand-region.el
#+BEGIN_SRC emacs-lisp
(el-get-bundle expand-region)
(require 'expand-region)
(global-set-key (kbd "C-+") 'er/expand-region)
#+END_SRC
** setup-go.el
#+BEGIN_SRC emacs-lisp
(defun system-has-go () "Tests wether go is installed or not" 
       (condition-case nil
           (progn
             (start-process "" nil "go")
             t
             )
         (error nil))
       )
(defun makeinfo-version () "Make info version"
       (with-temp-buffer
          (call-process "makeinfo" nil t nil "--version")
          (goto-char (point-min))
          (re-search-forward "[0-9]\\{1,2\\}\\(\\.[0-9]\\{1,2\\}\\)\\{1,2\\}")
          (let ((s (match-beginning 0)) (e (point)))
            (mapcar
             'string-to-number
             (split-string (buffer-substring s e) "\\.")))))




(defun setup-go () "Install go environment with el-get"
       (el-get-bundle go-mode)
       (el-get-bundle dash)
       
       ;; Require makeinfo which major version is 5 or more
       (if (< 4 (car (makeinfo-version)))
           (progn
           (el-get-bundle flycheck)   
           ;; go get github.com/dougm/goflymake
           (add-to-list 'load-path "~/src/github.com/dougm/goflymake")
           (require 'go-flycheck))
           ))

       

       ;; go get github.com/nsf/gocode
       (el-get-bundle go-autocomplete)
       (require 'go-autocomplete)

       (add-hook 'go-mode-hook 
                 (lambda ()
                         (add-hook 'before-save-hook 'gofmt-before-save))
                 )

(if (system-has-go) (setup-go))
#+END_SRC
** setup-idea.el
#+BEGIN_SRC emacs-lisp
;; Idea related shortcuts

(defun idea-open-file (s) "Opens file in idea"
       (interactive
        (list (idea-open-file (buffer-substring (region-beginning) (region-end)))))
       (start-process "" nil "idea" s)
       )

#+END_SRC
** setup-jira.el
#+BEGIN_SRC emacs-lisp
(el-get-bundle org-jira)
(setq org-jira-working-dir "~/org/jira")
#+END_SRC
** setup-multicursore.el
#+BEGIN_SRC emacs-lisp
(el-get-bundle multiple-cursors)
#+END_SRC
** setup-mysql.el
#+BEGIN_SRC emacs-lisp
;; Allows changing port used to connect MySQL-database
;(setq sql-mysql-login-params (append sql-mysql-login-params '(port)))
;(setq sql-port 3306)
#+END_SRC
** setup-tramp.el
#+BEGIN_SRC emacs-lisp
(el-get-bundle tramp)
#+END_SRC
** setup-yaml.el
#+BEGIN_SRC emacs-lisp
(el-get-bundle yaml-mode)

#+END_SRC
** setup-yasnippet-and-ac.el
#+BEGIN_SRC emacs-lisp
(el-get-bundle yasnippet)
(el-get-bundle auto-complete)


(require 'yasnippet)
(require 'auto-complete)
(require 'auto-complete-config)
(require 'auto-complete-yasnippet)

(ac-config-default)
;(global-set-key (kbd "C-<tab>")  'yas-expand)

(setq ac-source-yasnippet nil)

;;; auto complete mod
;;; should be loaded after yasnippet so that they can work together

(add-to-list 'ac-dictionary-directories "~/.emacs.d/ac-dict")

;;; set the trigger key so that it can work together with yasnippet on tab key,
;;; if the word exists in yasnippet, pressing tab will cause yasnippet to
;;; activate, otherwise, auto-complete will
(ac-set-trigger-key "<tab>")



;; (setq-default ac-sources
;;       '(
;;         ;; ac-source-semantic
;;         ac-source-yasnippet
;;         ac-source-abbrev
;;         ac-source-words-in-buffer
;;         ac-source-words-in-all-buffer
;;         ;; ac-source-imenu
;;         ac-source-files-in-current-dir
;;         ac-source-filename
;;         )
;;       )

(yas-global-mode 1)
(global-auto-complete-mode 1)

 (defadvice ac-fallback-command (around no-yasnippet-fallback activate)
      (let ((yas-fallback-behavior nil))
        ad-do-it))
#+END_SRC
** Buffer switching

One common task is to switch between two buffers.
Suspend frame is not very usefull command so, it is
recucled to change the buffer.

#+begin_src emacs-lisp
(global-set-key (kbd "C-z")  'mode-line-other-buffer)
#+end_src

** IBuffers

#+begin_src emacs-lisp
   (global-set-key (kbd "C-x C-b") 'ibuffer)
   (autoload 'ibuffer "ibuffer" "List buffers." t)

    (setq ibuffer-saved-filter-groups
            (quote (("default"
                     ("dired" (mode . dired-mode))
                     ("org" (or
                             (mode . org-mode)
                             (mode . org-agenda-mode)                           
                             ))
                     ("emacs" (or
                               (name . "^\\*scratch\\*$")
                               (name . "^\\*Messages\\*$")))
                     ("shell" (or
                              (mode . shell-mode)
                              (mode . term-mode)
                              ))))))

#+end_src
** COMMENT Kill buffer instead of burying it

#+begin_src emacs-lisp
(defadvice quit-window (before quit-window-always-kill)
  "When running `quit-window', always kill the buffer."
  (ad-set-arg 0 t))
(ad-activate 'quit-window)
#+end_src
** Default column width 120 characters
#+begin_src emacs-lisp
(setq default-fill-column 120)
#+end_src
** Theme

Plain white theme gets old after a while. Emacs has support themes and there is [[https://emacsthemes.com/][gallery]] of them.  Colors of IntelliJ
Idea Darcula theme pleases the eye. Emacs updates theme list only after init has been run. Hook is used to load theme
then.  Without it first loading would fail.

#+BEGIN_SRC emacs-lisp
  (el-get-install 'idea-darkula-theme)
  (push (substitute-in-file-name "~/.emacs.d/el-get/idea-darkula-theme/") custom-theme-load-path)
  (add-hook 'after-init-hook (lambda () (load-theme 'idea-darkula t)))

#+END_SRC

** Fonts

Editing a lot of text using fixed width font is not optimum situation. After a while of googling 
I found a way to use variable length fonts (see [[https://yoo2080.wordpress.com/2013/05/30/monospace-font-in-tables-and-source-code-blocks-in-org-mode-proportional-font-in-other-parts/][the blog of Jisan Yoo]]).

First we hook variable-pitch-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'variable-pitch-mode)
#+END_SRC

The problem is that I don't want code and tables to be variable width inside
Org mode document. This can be archived by altering some faces
used by the Org mode.

#+BEGIN_SRC emacs-lisp
  (defun my-adjoin-to-list-or-symbol (element list-or-symbol)
    (let ((list (if (not (listp list-or-symbol))
                    (list list-or-symbol)
                  list-or-symbol)))
      (require 'cl-lib)
      (cl-adjoin element list)))

    (mapc
      (lambda (face)
        (set-face-attribute
         face nil
         :inherit
         (my-adjoin-to-list-or-symbol
          'fixed-pitch
          (face-attribute face :inherit))))
      (list 'org-code 'org-block 'org-table 'org-meta-line))
#+END_SRC

Of course we can choose what kind of faces ~variable-pitch~ and ~fixed-pitch~ are.
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'variable-pitch nil :height 1.3 :family "Calibri")
(set-face-attribute 'fixed-pitch nil :height 0.8 :family "Consolas")
#+END_SRC

While we are at it we could make Org-mode look a little better in general.
#+BEGIN_SRC emacs-lisp
(require 'org-bullets)
(add-hook 'org-mode-hook 'org-indent-mode)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
(setq org-hide-leading-stars t)
(setq line-spacing 0.25)
(set-face-attribute 'org-tag nil :weight 'normal :height 0.8)
(set-face-attribute 'org-todo nil :weight 'normal :height 150)
(set-face-attribute 'org-priority nil :weight 'normal :height 100)
(set-face-attribute 'org-todo nil :weight 'normal :height 100)
(set-face-attribute 'org-done nil :weight 'normal :height 100)
(set-face-attribute 'org-special-keyword nil :height 90)
(set-face-attribute 'org-level-1 nil :height 1.3)
(set-face-attribute 'org-level-2 nil :height 1.2)
(set-face-attribute 'org-level-3 nil :height 1.1)
#+END_SRC

** Don't confirm kills

#+begin_src
(global-set-key (kbd "C-x k") 'kill-this-buffer)
(setq kill-buffer-query-functions '())
#+end_src

** Protocol Buffers  mode

[[https://developers.google.com/protocol-buffers/docs/overview][Google Protocol Buffers]] is way to serialize data. It uses "proto" files to describe serialization format.

#+begin_src emacs-lisp
(require 'protobuf-mode)
(add-to-list 'auto-mode-alist '("\\.proto\\'" . protobuf-mode))
#+end_src

** Open current buffer in idea
#+begin_src emacs-lisp
  (defun open-buffer-curent-idea ()
    ""
    (interactive)
    (call-process "idea" nil nil nil (buffer-file-name))
    (if (string-equal system-type "darwin")
        (ns-do-applescript "tell application \"IntelliJ Idea\" to activate")
      )
  )

  (global-set-key (kbd "C-q C-o")  'open-buffer-curent-idea)
#+end_src

** Toggle transparency of current frame

Sometime it is nice to look what is behind the frame. Following code toggles frame to be almost completely transparent
and back to solid again. 
#+begin_src emacs-lisp
  (defun pw/toggle-transparency ()
    "Toggles frame transparency."
    (interactive)
    (if (equal '(100 100) (frame-parameter (selected-frame) 'alpha))
        (set-frame-parameter (selected-frame) 'alpha '(10 10))
      (set-frame-parameter (selected-frame) 'alpha '(100 100))))

  (global-set-key (kbd "C-x C-t")  'pw/toggle-transparency)
#+end_src

** PlantUML mode

PlantUML works using JAR. Next is function that will load the jar if it is missing. Function returns the path where the
jar was loaded.

#+begin_src emacs-lisp
  (defun pw/download-plantuml-jar-if-needed () ""
         (let ((plantuml-jar "~/.emacs.d/plantuml.jar"))
           (if (not (file-exists-p plantuml-jar))
               (progn
                 (url-copy-file "http://downloads.sourceforge.net/project/plantuml/plantuml.jar?r=http%3A%2F%2Fplantuml.com%2Fdownload.html&ts=1441279540&use_mirror=netix" plantuml-jar)
                 ))
           (expand-file-name plantuml-jar)))
#+end_src

Now we can set the PlantUML jar for org-mode.
#+begin_src emacs-lisp
  (setq org-plantuml-jar-path  (pw/download-plantuml-jar-if-needed))

  ;; Don`t confirm plant uml runs for conviency.
  (lexical-let ((default-confirm org-confirm-babel-evaluate))
    (defun my-org-confirm-babel-evaluate (lang body)
      (if (string= lang "plantuml") nil default-confirm))
    (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
    )
#+end_src

There is mode for Plant UML, but no el-get recipe for it. So we create one.
#+begin_src emacs-lisp :mkdir yes :tangle el-get-user/recipes/puml-mode.rcp
(:name puml-mode
       :description "PlantUML Mode"
       :type git
       :url "https://github.com/skuro/puml-mode")
#+end_src

Now the recipe can be installed. It also needs to know where the jar is.
#+begin_src emacs-lisp
  (el-get-install 'puml-mode)
  (setq org-plantuml-jar-path (pw/download-plantuml-jar-if-needed))
#+end_src

As there is no plantuml-mode we need to set up puml-mode for plantuml.
#+begin_src emacs-lisp
  (add-to-list 'org-src-lang-modes '("plantuml" . puml))
#+end_src

** Run local init

Finally after all the other initializations

#+BEGIN_SRC emacs-lisp
  (setq local-init-file "~/.emacs.d/local-init.el")
  (if (file-exists-p local-init-file)
  (load local-init-file)
  )
#+END_SRC
